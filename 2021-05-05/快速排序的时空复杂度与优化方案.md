## 快速排序的空间复杂度是多少？时间复杂度的最好最坏的情况是多少，有哪些优化方案？

快排过程可以分为两个部分，第一个过程是对数组进行二分操作，直到二分得到的区间不能再分为止。第二个过程则是在第一部得到的各个子区间中，取一个枢纽元元素，将子区间中比这个元素大的放一边，比他小的放另一边。
#### 时间复杂度
这两个过程时间复杂度显然是O(logn)和O(n)，由于每次第一步中二分得到的区间里都要进行第二步O(n)的操作，所以总的时间复杂度应该是O(n*logn)。

#### 空间复杂度
第一个过程可以使用递归使用，这样就需要O(logn)的栈空间（非递归使用需要借助栈，同样需要O(logn)的空间）。

#### 最好和最坏的情况

- 最坏：最坏的情况是第二步中每次取的枢纽元刚好是子区间里最小或者最大的，这样第二步子区间交换结束后，实际上只交换了至多一个元素，其余元素还处于”按兵不动“的状态，相当于退化成冒泡排序了。第二步的时间复杂度也会从O(logn)退化到O(n)，总时间复杂度O(n^2)。同理，空间复杂度也会退化到O(n)。
- 最好：相对而言，最好的情况就是枢纽元刚好是子区间内的中位数，可以很有”区分度“地把子区间从中点分成两半，第二步子区间交换结束后，元素都移动到更接近目标位置的地方，后续的递归次数也能因此降低。时间复杂度是O(n*logn)，空间复杂度为O(logn)。

#### 优化方案
1、结合插入排序。插入排序有以下两个优点

- 在数组几乎有序的情况下，插入排序效率很高，完全有序情况下，能达到O(n)。
- 数据量小的时候，插入排序效率很高。大O描述的是数据规模无穷大的场景。数据规模小的时候，常数项很可能比n更大，而插入排序就是一个常数项很小的算法。

2、枢纽元选取优化。通常使用三数取中法（最左侧、中间、最右侧三个元素取中间大小的那个）。在数组有序，乱序情况下都能避免最坏情况，表现较好。

3、三路快排，重复元素多的时候，对重复元素会重复执行partition，递归树倾斜，导致O(logn)劣化成O(n)。三路快排把数组分成三个部分：

- 小于枢纽元[l,midL]
- 等于枢纽元[midL+1,midR]
- 大于枢纽元[midR+1,r]

[midL+1,midR]已经有序，所以下一步递归处理[l,midL]和[midR+1,r]即可。
